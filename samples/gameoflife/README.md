# ライフゲーム

このサンプルは p5.js を使ってライフゲームを作成するものです。

![ライフゲームのgif画像](/samples/gameoflife/images/lifegame.gif)

## 必要スキル&知識

- ピクセルアートをやっている前提
- 前の値を元に変数を更新(インクリメント、デクリメント)
- 配列は参照渡しになる

## ライフゲームとは

> ライフゲーム (Conway's Game of Life[1]) は 1970 年にイギリスの数学者ジョン・ホートン・コンウェイ (John Horton Conway) が考案した数理モデルである。単純なルールから複雑な結果が生成され、パズルやミニスケープの要素を持っている。生命の誕生、進化、淘汰などのプロセスを連想させるパターンも存在し、シミュレーションゲームと分類される場合がある。

[wikipedia ライフゲームを参照](https://ja.wikipedia.org/wiki/%E3%83%A9%E3%82%A4%E3%83%95%E3%82%B2%E3%83%BC%E3%83%A0)

## ルール

ライフゲームでは初期状態のみでその後の状態が決定される。碁盤のような格子があり、一つの格子はセル（細胞）と呼ばれる。各セルには 8 つの近傍のセルがある (ムーア近傍) 。各セルには「生」と「死」の 2 つの状態があり、あるセルの次のステップ（世代）の状態は周囲の 8 つのセルの今の世代における状態により決定される。

セルの生死は次のルールに従う。

### 誕生

死んでいるセルに隣接する生きたセルがちょうど 3 つあれば、次の世代が誕生する。

### 生存

生きているセルに隣接する生きたセルが 2 つか 3 つならば、次の世代でも生存する。

### 過疎

生きているセルに隣接する生きたセルが 1 つ以下ならば、過疎により死滅する。

### 過密

生きているセルに隣接する生きたセルが 4 つ以上ならば、過密により死滅する。

また、今回簡単にするため、端のセルは死んだ状態を保つこととします。

## Get Started!

### ステップ1 セルで埋め尽くそう
ステップ1の内容はピクセルアートとほぼ一緒なので割愛します。キャンバスを初期状態を死んだ状態のセルで埋め尽くしてください。

```js
// 変数の宣言
let w; // セルの幅(ピクセル)
let columns; // 列数
let rows; // 行数
let cells; // セルの状態2次元配列

function setup() {
  // フレームレートを24フレーム/秒に設定
  // frameRate(24);

  // キャンバスの大きさを720x400ピクセルに指定
  createCanvas(720, 400);
  // 背景色をカラーコード#E0F4FFに指定
  background("#E0F4FF");

  // セルの幅を20ピクセルに指定
  w = 20;

  // 行数の計算
  rows = 400 / w;

  // 列数の計算
  columns = 720 / w;

  init();
}

function draw() {
  // 行ループ
  for (let i = 0; i < rows; i++) {
    // 列ループ
    for (let j = 0; j < columns; j++) {
      if (cells[i][j] === "x") {
        fill(0); // 黒で塗りつぶし
      } else {
        fill(255); // 白で塗りつぶし
      }
      rect(j * w, i * w, w, w);
    }
  }
}

function init() {
  // cellsを20行36列の2次元配列として、"x"で埋めるコード

  // 行数分のundefined要素をもった配列で初期化
  cells = new Array(rows);

  // 行ループ
  for (let i = 0; i < rows; i++) {
    // さらに要素ごとに、列数分のundefined要素をを持った配列で初期化
    cells[i] = new Array(columns);

    // 列ループ
    for (let j = 0; j < columns; j++) {
      // 初期状態は死んだ状態にする
      cells[i][j] = 'x';

    }
  }
}
```

### ステップ2 セルの生存と死滅のルールを適用させよう
このままだと、単なるピクセルアートな静止画のままです。ライフゲームのアルゴリズムを適用させてこのピクセルアートに命を吹き込みましょう。


```js
// 省略

function draw() {
  // 追加
  goNextGeneration()

  // 行ループ
  for(let i = 0; i < rows; i++){
    // 列ループ
    for(let j = 0; j < columns; j++){
      if(cells[i][j] === 'x'){
        fill(0) // 黒で塗りつぶし
      } else {
        fill(255) // 白で塗りつぶし
      }
      rect(j*w, i*w, w, w);
    }
  }
}

// 現在のcellsの値をもとに次の世代のcellsの値を決める
function goNextGeneration(){
  // ここにコードを追加
}
```

改めてライフゲームのルールを確認しましょう。

- そのセルが死んでいたとする。そのセルに隣接するセルのうちちょうど３つが生きていれば、次の世代で、そのセルは誕生する。
- そのセルが生きていたとする。そのセルに隣接するセルのうちちょうど２つか３つが生きていれば、次の世代で、そのセルは生存する。
- そのセルが生きていたとする。そのセルに隣接するセルのうち1つ以下しか生きていなければ、次の世代で、そのセルは過疎により死滅する。
- そのセルが生きていたとする。そのセルに隣接するセルのうち4つ以上のセルが生きていれば、次の世代で、そのセルは過密により死滅する。

これを実現するにはどうすればよいでしょうか？ 1つ1つ見ていきましょう。

> そのセルが死んでいたとする。そのセルに隣接するセルのうちちょうど３つが生きていれば、次の世代で、そのセルは誕生する

これをチェックするには、適当な１つのセルを選択して、まずはそのセルが'x'かどうかチェックします。そして、さらに周囲のセルの状態を調べる必要がありますね。周囲のセルのうち、３つが'o'であれば、次の世代で、そのセルは'o'になります。これをすべてのセルでチェックしていく必要があります。

> そのセルが生きていたとする。そのセルに隣接するセルのうちちょうど２つか３つが生きていれば、次の世代で、そのセルは生存する。

これをチェックするには、適当な１つのセルを選択して、まずはそのセルが'o'かどうかチェックします。そして、さらに周囲のセルのうち、2つか３つ'o'であれば、次の世代で、そのセルは'o'のまま維持されます。これをすべてのセルでチェックしていく必要があります。

ほか２つの条件も自分で考えてみましょう。

そして、すべての条件を眺めたとき、いくつか共通のものがあると思います。

- すべてのセルをチェックしないといけない。
- ターゲットとなるセルの周囲のセルすべてをチェックしないといけない。
- 周囲のセルの状態に応じてターゲットのセルの次の状態が変わる。
- 次の世代に現在の状態を更新しないといけない。

> すべてのセルをチェックしないといけない。
これを実現するには現在の`cells`の状態をすべて調べる必要があります。`cells`自体は2次元配列なので、１つ１つの要素をチェックするには2重ループが必要そうです。

> ターゲットとなるセルの周囲のセルすべてをチェックしないといけない。
ターゲットの周囲のセルの状態をどうやって取得すればよいのでしょうか？こういうときは図を書くとわかりやすいです。

|(0,0)|(0,1)|(0,2)|...|(0,35)|
|---|---|---|---|---|
|(1,0)|(1,1)|(1,2)|...|(1,35)|
|(2,0)|(2,1)|(2,2)|...|(2,35)|
|...|...|...|...|...|
|(19,0)|(19,1)|(19,2)|...|(19,35)|

例えば、2行目2列(1,1)の周囲は次の9つです。
- (0,0)
- (0,1)
- (0,2)
- (1,0)
- (1,2)
- (2,0)
- (2,1)
- (2,2)

これを一般化するとターゲットのセルi行目j列目(i,j)に対して
- 左上 (i-1,j-1)
- 真上 (i-1, j)
- 右上 (i-1, j+1)
- 左   (i, j-1)
- 右   (i, j+1)
- 左下 (i+1, j-1)
- 真下 (i+1, j)
- 右下 (i+1, j+1)
が周囲のセルと言えそうです。

> 周囲のセルの状態に応じてターゲットのセルの次の状態が変わる。
周囲のセルの状態の取得の仕方はわかりました。あとはそれぞれのルールをチェックすれば、ターゲットのセルの次の世代が'o'なのか'x'なのかわかります。

> 次の世代に現在の状態を更新しないといけない。
ここは少しむずかしいところです。次の世代に状態を更新するということで次のようなコードを考えるかもしれません。

```js
for(let i = 0; i < rows; i++){
  for(let j = 0; j < columns; j++){
    // 周囲のセルの条件をチェックして
    if(){
      // cellsの値を更新
      cells[i][j] = 'o'
    }
  }
}

```

このコードは実際はうまくいきません。というのは、すべてのセルをチェックする(2重ループが終わる)まえに`cells`の値を変えては行けないのです。次の世代の状態は現在の状態によって決まります。もし2重ループのなかで`cells`の値を変えてしまうと、現在の状態が書き換わってしまい、他のターゲットのセルをチェックする際に整合性がとれなくなってしまうのです。そこで2重ループが終わるまでは次の世代の状態は他の変数`next`に保持して置きましょう！ちなみに`next`も`cells`と同様に'x'で初期化しておきます。

ここまでのコード:

```js
// 省略
let next; // 次世代のセルの状態を保持する。

function setup(){
  // フレームレートを24フレーム/秒に設定
  frameRate(24);

  // キャンバスの大きさを720x400ピクセルに指定
  createCanvas(720, 400);
  // 背景色をカラーコード#E0F4FFに指定
  background('#E0F4FF');

  // セルの幅を20ピクセルに指定
  w = 20;

  // 行数の計算
  rows = 400 / w;

  // 列数の計算
  columns = 720 / w;

  // コンソールにcolumnsとrowsの値を出力
  console.log('行数:', rows)
  console.log('列数:', columns)

  init()
  console.log(cells)
}

function init(){
  // 行数分のundefined要素をもった配列で初期化
  cells = new Array(rows);

  // 行ループ
  for (let i = 0; i < rows; i++) {
    // さらに要素ごとに、列数分のundefined要素をを持った配列で初期化
    cells[i] = new Array(columns);

    // 列ループ
    for (let j = 0; j < columns; j++) {
      // i行目j列目の要素を'x'で埋める
      cells[i][j] = 'x'
    }
  }

    // 行数分のundefined要素をもった配列で初期化
  next = new Array(rows);

  // 行ループ
  for (let i = 0; i < rows; i++) {
    // さらに要素ごとに、列数分のundefined要素をを持った配列で初期化
     next[i] = new Array(columns);

    // 列ループ
    for (let j = 0; j < columns; j++) {
      // i行目j列目の要素を'x'で埋める
      next[i][j] = 'x'
    }
  }
}


function draw() {
  goNextGeneration()

  // 行ループ
  for(let i = 0; i < rows; i++){
    // 列ループ
    for(let j = 0; j < columns; j++){
      if(cells[i][j] === 'x'){
        fill(0) // 黒で塗りつぶし
      } else {
        fill(255) // 白で塗りつぶし
      }
      rect(j*w, i*w, w, w);
    }
  }
}

// 現在のcellsの値をもとに次の世代のcellsの値を決める
function goNextGeneration(){
  // ここにコードを追加
}
```

あとは`goNextGeneration`を実装するだけですね!ここまでの考察をもとに以下のルールを書いてみましょう。

> そのセルが死んでいたとする。そのセルに隣接するセルのうちちょうど３つが生きていれば、次の世代で、そのセルは誕生する。

```js
function goNextGeneration(){
  for(let i = 0; i < rows; i++){
    for(let j = 0; j < columns; j++){
      // 周囲のセルの条件をチェック
      // そのセルが死んでいたとする。そのセルに隣接するセルのうちちょうど３つが生きていれば、次の世代で、そのセルは誕生する。
      if(cells[i][j] === 'x' 
        && cells[i-1][j-1] === 'o' // 左上
        && cells[i-1][j] === 'o' // 真上
        && cells[i-1][j+1] === 'o' // 右上
        && cells[i][j-1] === 'o' //左 
        && cells[i][j+1] === 'o' //　右
        && cells[i+1][j-1] === 'o' //　左下
        && cells[i+1][j] === 'o' //　真下
        && cells[i+1][j+1] === 'o' //　右下
        ){
        // nextの値を更新
        next[i][j] = 'o'
      }
    }
  }

  // 置き換える
  cells = next;
}
```

とここまで書いたところで、次の問題に当たります。

- cells[i-1][j-1]がない場合はどうするの？例えば一番左上のセルには、左上、真上、右上、左、左下が存在しないため、undefinedエラーになってしまう。
- 隣接するセルで生きているセルが3つとはどう判断すればよい？ 

最初の問題は難しいので、今回簡単化のため、端っこ乗せるは常に死んでいるとしましょう。つまり端っこのセルはチェックしなくてもよくなるので、2重ループの始まりと終わりの条件が変わります。

```js
function goNextGeneration(){
  // 端っこは無視してよい。
  for(let i = 1; i < rows - 1; i++){
    for(let j = 1; j < columns - 1; j++){
      // 周囲のセルの条件をチェック
     　
    }
  }

  // 置き換える
  cells = next;
}
```

1つ目の問題は解決しました。つぎは2つ目の問題です。ここで大切なことは、隣接するセルが'o'かどうかをチェックするのではなく、実は隣接するセルに何個の'o'があるかどうかです。まずは隣接するセルの'o'の数を数えましょう！隣接するセルの'o'の数を保持する変数を`neighbors`(ご近所さん)とします。ご近所さんが'o'の数を数えていきます。

```js
function goNextGeneration(){
  for(let i = 1; i < rows - 1; i++){
    for(let j = 1; j < columns - 1; j++){
      // 周囲のセルの条件をチェック
      // 隣接するセルの'o'の数をカウント
      let neighbors = 0;
      // 左上
      if(cells[i-1][j-1] === 'o') {
        neighbors++;
      }
      // 真上
      if(cells[i-1][j] === 'o') {
        neighbors++;
      }
      // 右上
      if(cells[i-1][j+1] === 'o') {
        neighbors++;
      }
      // 左
      if(cells[i][j-1] === 'o') {
        neighbors++;
      }
      // 右
      if(cells[i][j+1] === 'o') {
        neighbors++;
      }
      // 左下
      if(cells[i+1][j-1] === 'o') {
        neighbors++;
      }
      // 真下
      if(cells[i+1][j] === 'o') {
        neighbors++;
      }
      // 右下
      if(cells[i+1][j+1] === 'o') {
        neighbors++;
      }


    }
  }

  // 置き換える
  cells = next;
}
```

そして、次にご近所さんの'o'の数に応じて次の世代の、ターゲットのセルの生死が決まります。


```js
function goNextGeneration(){
  for(let i = 1; i < rows - 1; i++){
    for(let j = 1; j < columns - 1; j++){
      // 周囲のセルの条件をチェック
      // 隣接するセルの'o'の数をカウント
      let neighbors = 0;
      // 左上
      if(cells[i-1][j-1] === 'o') {
        neighbors++;
      }
      // 真上
      if(cells[i-1][j] === 'o') {
        neighbors++;
      }
      // 右上
      if(cells[i-1][j+1] === 'o') {
        neighbors++;
      }
      // 左
      if(cells[i][j-1] === 'o') {
        neighbors++;
      }
      // 右
      if(cells[i][j+1] === 'o') {
        neighbors++;
      }
      // 左下
      if(cells[i+1][j-1] === 'o') {
        neighbors++;
      }
      // 真下
      if(cells[i+1][j] === 'o') {
        neighbors++;
      }
      // 右下
      if(cells[i+1][j+1] === 'o') {
        neighbors++;
      }

      // そのセルが死んでいたとする。そのセルに隣接するセルのうちちょうど３つが生きていれば、次の世代で、そのセルは誕生する。
      if(cells[i][j] === 'x' && neighbors === 3) {
        next[i][j] === 'o'
      }
      // そのセルが生きていたとする。そのセルに隣接するセルのうち4つ以上のセルが生きていれば、次の世代で、そのセルは過密により死滅する。
      else if(cells[i][j] === 'o' && neighbors > 3) {
        next[i][j] === 'x'
      }
      // そのセルが生きていたとする。そのセルに隣接するセルのうちちょうど２つか３つが生きていれば、次の世代で、そのセルは生存する。
      else if(cells[i][j] === 'o' && neighbors >= 2) {
        next[i][j] === 'o'
      }
      // そのセルが生きていたとする。そのセルに隣接するセルのうち1つ以下しか生きていなければ、次の世代で、そのセルは過疎により死滅する。
      if(cells[i][j] === 'o' && neighbors <= 1) {
        next[i][j] === 'x'
      }
    }
  }

  // 世代を置き換える
  cells = next;
}
```